Basic usage is to:

    #include "ltjson.h"

Declare a jsontree and init the pointer to NULL (important):

    ltjson_node_t *jsontree = 0;

Parse the tree in buffer into the jsontree:

    ret = ltjson_parse(&jsontree, buffer);

This will allocate memory as needed. If the tree in buffer is incomplete,
ret will be 0 with errno set to -EAGAIN and you can call ltjson_parse
again with the same parameters. If there's an error ret will be 0 with
errno set to ENOMEM, EILSEQ or EINVAL
(see function descriptions below).

Once ret is 1 you can display the tree to the console with:

    ltjson_display(jsontree, 0);

/**
 *  ltjson_parse(treeptr, text, usehash) - Parse text into JSON tree
 *      @treeptr:   Pointer to json tree root
 *      @text:      UTF-8 text
 *      @usehash:   Use a hash to find duplicate node names
 *
 *  Scan the JSON provided @text and parse it into the tree which is
 *  pointed to by treeptr. If @*treeptr is NULL then a new tree is created.
 *  If not NULL the memory storage is reused if the tree is closed or
 *  text continues to be added if the tree is open.
 *
 *  If @text is NULL, the tree is forced closed and into an error state.
 *
 *  If @usehash is true, a new or recycled tree will obtain a name
 *  lookup hash table. This is really only useful for large trees with
 *  many duplicate names. If false, a recycled tree will lose the hash.
 *
 *  Returns:  1 on success and the tree is parsed and closed
 *            0 on error or tree is incomplete and errno is set to:
 *              EAGAIN if tree incomplete and more text needed
 *              EINVAL if invalid argument
 *              EILSEQ if invalid JSON sequence (reason available)
 *              ENOMEM if out of memory
 *
 *  On ENOMEM, all storage will be freed and *treeptr is set to NULL
 */

/**
 *  ltjson_free(treeptr) - Free up all memory associate with tree
 *      @treeptr:   Pointer to valid tree
 *
 *  Returns:    1 on success, writing NULL to *treeptr
 *              0 and errno set to EINVAL if tree is not valid
 */

/**
 *  ltjson_pathrefer(tree, path, nodeptr, nnodes) - Search for nodes
 *      @tree:      Valid closed and finalised (no error state) tree
 *      @path:      Reference path expression
 *      @nodeptr:   Pointer to nodestore for the answer
 *      @nnodes:    Number of available nodes in @nodeptr
 *
 *  Search the tree for the items specified in path and store any matches
 *  found into the @nodeptr node array up to a max of @nnodes.
 *
 *  The reference path is an expression that must start with a / to
 *  represent the root, followed by / separated object or array
 *  references. Use [] to represent array offsets:
 *          /phoneNumbers/type
 *          /phoneNumbers[1]/type
 *          /[3]/store/book
 *  An array offset can be left out or represented by [] or [*] to
 *  denote "all elements" in the array. The offset is 0 based.
 *  If an array is last item in a path, the array is returned, not
 *  all the elements of the array (as for other parts of the path).
 *
 *  Returns: Number of matches found (not stored) on success or
 *           0 on failure and, if an error, sets errno to one of
 *              EINVAL if tree is not valid, closed or finalised
 *              EILSEQ if path expression is not understood
 *              ERANGE if path is too long
 */

/**
 *  ltjson_lasterror(tree) - Describe the last error that occurred
 *      @tree:  Valid tree
 *
 *  Returns: A pointer to a constant string describing the error
 */

/**
 *  ltjson_display(tree) - Display the contents of the JSON tree
 *      @tree:   Valid closed tree
 *      @rnode:  Optional node to act as display root (NULL if unused)
 *
 *  Returns: 1 on success
 *           0 if tree is not valid/closed and sets errno (EINVAL)
 */

/**
 *  ltjson_memstat(tree, stats, nents) - get memory usage statistics
 *      @tree:  Valid tree
 *      @stats: Pointer to an array of ints which is filled
 *      @nents: Number of entries in stats
 *
 *  Tree does not have to be closed. No changes are made
 *
 *  Returns: the number of stats placed in stats array
 *           0 if tree/stats/nents not valid and sets errno (EINVAL)
 */

/**
 *  ltjson_statstring(index) - return statistic description string
 *      @index:  Valid index
 *
 *  Returns: a const char string description of the statistic
 *           NULL if index is invalid (errno to ERANGE)
 */

/**
 *  ltjson_statdump(tree) - print out memory usage statistics
 *      @tree:  Valid tree
 *
 *  Tree does not have to be closed. No changes are made
 */

/**
 *  ltjson_findname(tree, name, nodeptr) - Find name in tree
 *      @tree:  Valid closed tree
 *      @name:  Search text (utf-8)
 *      @node:  Optional starting point
 *
 *  If node is NULL, the search begins at the root of the tree.
 *  Otherwise, the search proceeds from *after* that node point.
 *
 *  Returns: a pointer to the matched node on success
 *           NULL on failure setting errno to EINVAL if error
 */

